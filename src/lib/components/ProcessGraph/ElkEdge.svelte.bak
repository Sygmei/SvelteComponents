<script lang="ts">
    import { BaseEdge, type EdgeProps } from "@xyflow/svelte";
    import {
        groupBoxesStore,
        groupPortsStore,
        allEdgesStore,
        type GroupBox,
        type EdgeEndpoints,
    } from "./graphUtils";
    import { get } from "svelte/store";
    import { onMount, onDestroy } from "svelte";

    type $$Props = EdgeProps;

    export let id: $$Props["id"];
    export let sourceX: $$Props["sourceX"];
    export let sourceY: $$Props["sourceY"];
    export let targetX: $$Props["targetX"];
    export let targetY: $$Props["targetY"];
    export let sourcePosition: $$Props["sourcePosition"] = undefined;
    export let targetPosition: $$Props["targetPosition"] = undefined;
    export let style: $$Props["style"] = undefined;
    export let markerEnd: $$Props["markerEnd"] = undefined;
    export let source: string = "";
    export let target: string = "";
    export let data: Record<string, unknown> = {};

    // Suppress unused warnings
    void sourcePosition;
    void targetPosition;
    void data;

    const MARGIN = 40; // Minimum distance from group boundary for turns, entry/exit ports, and avoidance paths

    // Register this edge's endpoints for confluence calculation
    onMount(() => {
        allEdgesStore.update(edges => {
            // Remove any existing entry for this edge (in case of re-render)
            const filtered = edges.filter(e => e.id !== id);
            return [...filtered, {
                id,
                source,
                target,
                sourceX,
                sourceY,
                targetX,
                targetY
            }];
        });
    });

    onDestroy(() => {
        allEdgesStore.update(edges => edges.filter(e => e.id !== id));
    });

    // Update edge endpoints when they change (only if values actually changed)
    let lastSourceX = sourceX;
    let lastSourceY = sourceY;
    let lastTargetX = targetX;
    let lastTargetY = targetY;
    
    $: {
        if (sourceX !== lastSourceX || sourceY !== lastSourceY || 
            targetX !== lastTargetX || targetY !== lastTargetY) {
            lastSourceX = sourceX;
            lastSourceY = sourceY;
            lastTargetX = targetX;
            lastTargetY = targetY;
            
            allEdgesStore.update(edges => {
                const idx = edges.findIndex(e => e.id === id);
                if (idx >= 0) {
                    edges[idx] = { id, source, target, sourceX, sourceY, targetX, targetY };
                    return [...edges];
                }
                return edges;
            });
        }
    }

    // Get sibling edges (edges going to the same target)
    function getSiblingEdgesToTarget(): EdgeEndpoints[] {
        const allEdges = get(allEdgesStore);
        return allEdges.filter(e => e.target === target && e.id !== id);
    }

    // Get sibling edges (edges coming from the same source)
    function getSiblingEdgesFromSource(): EdgeEndpoints[] {
        const allEdges = get(allEdgesStore);
        return allEdges.filter(e => e.source === source && e.id !== id);
    }

    // Calculate confluence point for edges merging to the same target
    // Returns { x, y } where all sibling edges should merge before going to target
    // ALWAYS returns confluence Y at targetY - MARGIN if edge is not straight
    function getConfluencePoint(): { x: number; y: number } | null {
        // Confluence point is at targetX, and MARGIN above the target
        const confluenceY = targetY - MARGIN;
        
        // If confluence Y would be too close to source, don't use confluence
        if (confluenceY <= sourceY + 20) return null;
        
        return { x: targetX, y: confluenceY };
    }

    // Calculate divergence point for edges splitting from the same source
    // Returns { x, y } where all sibling edges should diverge from source
    // ALWAYS returns divergence Y at sourceY + MARGIN if edge is not straight
    function getDivergencePoint(): { x: number; y: number } | null {
        // Divergence point is at sourceX, and MARGIN below the source
        const divergenceY = sourceY + MARGIN;
        
        // If divergence Y would be too close to target, don't use divergence
        if (divergenceY >= targetY - 20) return null;
        
        return { x: sourceX, y: divergenceY };
    }

    // Get the group hierarchy for a node (returns array from innermost to outermost)
    function getGroupHierarchy(nodeId: string): string[] {
        const groups: string[] = [];

        if (nodeId.startsWith("group-")) {
            // Node is a group itself
            const groupId = nodeId.replace("group-", "");
            const parts = groupId.split(".");
            // Add parent groups (not the group itself)
            for (let i = parts.length - 1; i >= 1; i--) {
                groups.push("group-" + parts.slice(0, i).join("."));
            }
        } else {
            // Regular process node
            const parts = nodeId.split(".");
            for (let i = parts.length - 1; i >= 1; i--) {
                groups.push("group-" + parts.slice(0, i).join("."));
            }
        }

        return groups;
    }

    // Check if node is inside a group (at any level)
    function isInsideGroup(nodeId: string, groupId: string): boolean {
        const hierarchy = getGroupHierarchy(nodeId);
        return hierarchy.includes(groupId);
    }

    // Find which groups we need to exit from source and enter to reach target
    function findGroupTransitions(
        sourceId: string,
        targetId: string,
    ): {
        exitGroups: string[];
        entryGroups: string[];
        commonAncestor: string | null;
    } {
        const sourceGroups = getGroupHierarchy(sourceId);
        const targetGroups = getGroupHierarchy(targetId);

        // Find common ancestor
        let commonAncestor: string | null = null;
        for (const sg of sourceGroups) {
            if (targetGroups.includes(sg)) {
                commonAncestor = sg;
                break;
            }
        }

        // Groups to exit: source groups that are not ancestors of target
        const exitGroups: string[] = [];
        for (const sg of sourceGroups) {
            if (sg === commonAncestor) break;
            exitGroups.push(sg);
        }

        // Groups to enter: target groups that are not ancestors of source (in reverse order)
        const entryGroups: string[] = [];
        for (const tg of targetGroups) {
            if (tg === commonAncestor) break;
            entryGroups.push(tg);
        }
        entryGroups.reverse(); // Enter from outermost to innermost

        return { exitGroups, entryGroups, commonAncestor };
    }

    // Generate path with entry/exit port waypoints
    function getPath(): string {
        const boxes = get(groupBoxesStore);
        const ports = get(groupPortsStore);

        const boxMap = new Map<string, GroupBox>();
        boxes.forEach((b) => boxMap.set(b.id, b));

        // Find group transitions
        const { exitGroups, entryGroups, commonAncestor } =
            findGroupTransitions(source, target);

        // Build waypoints
        const waypoints: Array<{ x: number; y: number }> = [];
        waypoints.push({ x: sourceX, y: sourceY });

        // Add exit port waypoints for groups we're leaving
        // This ensures the edge visually exits through the group's exit port
        if (exitGroups.length > 0) {
            // For each exit group, add waypoints to route through its exit port
            for (const exitGroupId of exitGroups) {
                const exitPortKey = `${exitGroupId}-exit`;
                const exitPort = ports.get(exitPortKey);
                const exitBox = boxMap.get(exitGroupId);
                
                if (exitPort && exitBox) {
                    // First, go down to just above the exit port (align with bottom of group)
                    const preExitY = exitBox.y + exitBox.height - MARGIN / 2;
                    const lastWaypoint = waypoints[waypoints.length - 1];
                    
                    // Only add preExitY waypoint if we need to move down
                    if (preExitY > lastWaypoint.y) {
                        // Go down on current X
                        waypoints.push({ x: lastWaypoint.x, y: preExitY });
                        // Only add horizontal waypoint if exit port X is different
                        if (Math.abs(exitPort.x - lastWaypoint.x) > 1) {
                            waypoints.push({ x: exitPort.x, y: preExitY });
                        }
                    }
                    
                    // Then go through the exit port (only if different from last waypoint)
                    const currentLast = waypoints[waypoints.length - 1];
                    if (Math.abs(exitPort.x - currentLast.x) > 1 || Math.abs(exitPort.y - currentLast.y) > 1) {
                        waypoints.push({ x: exitPort.x, y: exitPort.y });
                    }
                }
            }
        }

        // Calculate intermediate turn point
        // If we're crossing groups, we need careful placement of the turn
        let turnY: number;
        const lastExitWaypoint = waypoints[waypoints.length - 1];
        const effectiveSourceY = lastExitWaypoint.y;
        const effectiveSourceX = lastExitWaypoint.x;

        // Check if we have sibling edges from the same source (for divergence)
        const siblingEdgesFromSource = getSiblingEdgesFromSource();
        const hasSiblings = siblingEdgesFromSource.length > 0;
        
        // If edge goes horizontally and has siblings from same source, use divergence point
        // This ensures all edges from the same source diverge at the same Y level
        const divergence = getDivergencePoint();
        const needsHorizontalMove = Math.abs(sourceX - targetX) > 1;
        const useDivergence = hasSiblings && needsHorizontalMove && divergence;

        if (entryGroups.length > 0) {
            // We're entering groups - place turn well above the first group to enter
            const firstEntryGroup = entryGroups[0];
            const entryBox = boxMap.get(firstEntryGroup);
            if (entryBox) {
                // Turn should be MARGIN above the group
                turnY = entryBox.y - MARGIN;
                // But not above the effective source (after exit waypoints)
                turnY = Math.max(turnY, effectiveSourceY + 20);
                
                // IMPORTANT: For DIVERGENCE consistency, we need to consider ALL sibling groups
                // at the same level, not just those in our direct path. This ensures all edges
                // from the same source split at the same Y level.
                const entryGroupParts = firstEntryGroup.replace("group-", "").split(".");
                const parentGroupId = entryGroupParts.slice(0, -1).join(".");
                
                if (parentGroupId) {
                    // Find ALL sibling groups at the same level (not just those in our X path)
                    // This ensures consistent divergence point across all edges from same source
                    // For divergence consistency, we look at ALL siblings between source and the
                    // group layer (not filtered by targetY, since different targets may have different Y)
                    const siblingGroups = boxes.filter((box) => {
                        if (!box.id.startsWith("group-")) return false;
                        if (box.id === firstEntryGroup) return false;
                        const boxGroupId = box.id.replace("group-", "");
                        const boxParts = boxGroupId.split(".");
                        // Same parent (sibling at same level)
                        const boxParent = boxParts.slice(0, -1).join(".");
                        if (boxParent !== parentGroupId) return false;
                        // Must be below the source (we're going down)
                        if (box.y + box.height <= effectiveSourceY) return false;
                        // NOTE: We intentionally do NOT filter by targetY here
                        // This ensures all edges from the same source consider ALL sibling groups
                        // for consistent divergence point calculation
                        return true;
                    });
                    
                    // Use the earliest turn point among all sibling groups
                    // This ensures all edges from the same source diverge at the same Y level
                    for (const sibling of siblingGroups) {
                        const siblingTurnY = sibling.y - MARGIN;
                        // Use >= to handle edge case where siblingTurnY is exactly at effectiveSourceY + buffer
                        if (siblingTurnY < turnY && siblingTurnY >= effectiveSourceY + 10) {
                            turnY = siblingTurnY;
                        }
                    }
                }
            } else {
                turnY = (effectiveSourceY + targetY) / 2;
            }
        } else if (exitGroups.length > 0) {
            // We're exiting groups but not entering any new ones
            // Since we've already added exit port waypoints, the turn should be
            // right after the last exit port (which is already in effectiveSourceY)
            // Just add a small offset to create a proper turn
            turnY = effectiveSourceY + MARGIN;
            // But not below the target
            turnY = Math.min(turnY, targetY - 20);
        } else if (commonAncestor) {
            // Both in the same group hierarchy - check if we need to go around sibling groups
            const ancestorBox = boxMap.get(commonAncestor);

            // Find sibling groups between source and target
            const siblingGroups = boxes.filter((box) => {
                if (box.id === commonAncestor) return false;
                // Check if this box is a direct child of the common ancestor
                const boxGroupId = box.id.replace("group-", "");
                const ancestorGroupId = commonAncestor.replace("group-", "");
                if (!boxGroupId.startsWith(ancestorGroupId + ".")) return false;
                // Check it's a direct child (one level deeper)
                const remaining = boxGroupId.slice(ancestorGroupId.length + 1);
                if (remaining.includes(".")) return false;
                // Check if it's between source and target Y
                return box.y > sourceY && box.y < targetY;
            });

            if (siblingGroups.length > 0) {
                // Check if we can go straight down (sourceX is in a gap between groups)
                // We can go straight if sourceX is not within MARGIN of any sibling group
                const canGoStraight = siblingGroups.every((box) => {
                    const boxLeftWithMargin = box.x - MARGIN;
                    const boxRightWithMargin = box.x + box.width + MARGIN;
                    // sourceX must be outside this box's X range (with margin)
                    return sourceX <= boxLeftWithMargin || sourceX >= boxRightWithMargin;
                });

                // Also check if targetX can be reached straight
                const canReachTargetStraight = siblingGroups.every((box) => {
                    const boxLeftWithMargin = box.x - MARGIN;
                    const boxRightWithMargin = box.x + box.width + MARGIN;
                    return targetX <= boxLeftWithMargin || targetX >= boxRightWithMargin;
                });

                if (canGoStraight && canReachTargetStraight && Math.abs(sourceX - targetX) < MARGIN) {
                    // We can go straight down - no need to turn around sibling groups
                    // Just use a simple turn near the source
                    turnY = sourceY + 20;
                } else {
                    // There's a sibling group blocking the path - turn above it
                    const firstSibling = siblingGroups.sort((a, b) => a.y - b.y)[0];
                    turnY = firstSibling.y - MARGIN;
                    turnY = Math.max(turnY, sourceY + 20);
                }
            } else {
                // No obstacles - simple turn at a good distance from source
                turnY = sourceY + 30;
            }
        } else {
            // No group involvement - check for any groups in the path
            const midY = (sourceY + targetY) / 2;

            // Find any group whose boundary is too close to midY
            let adjustedTurnY = midY;
            for (const box of boxes) {
                const boxTop = box.y;
                const boxBottom = box.y + box.height;

                // If midY is within MARGIN of a box boundary, adjust
                if (Math.abs(midY - boxTop) < MARGIN) {
                    adjustedTurnY = boxTop - MARGIN;
                } else if (Math.abs(midY - boxBottom) < MARGIN) {
                    adjustedTurnY = boxBottom + MARGIN;
                } else if (midY > boxTop && midY < boxBottom) {
                    // Turn would be inside a box - go above it
                    adjustedTurnY = boxTop - MARGIN;
                }
            }

            turnY = adjustedTurnY;
            turnY = Math.max(turnY, sourceY + 20);
            turnY = Math.min(turnY, targetY - 20);
        }

        // DIVERGENCE OVERRIDE: If there are sibling edges from same source and we need to turn,
        // use the divergence point (sourceY + MARGIN) to ensure all edges split at the same Y level
        if (useDivergence && divergence) {
            // For divergence: we want ALL edges from the same source to split at the SAME Y level
            // The divergence point is sourceY + MARGIN (a consistent point below the source)
            // 
            // Constraints:
            // - minAllowedTurnY: Can't turn too close to source (effectiveSourceY + 20)
            // - maxAllowedTurnY: Must turn before hitting any entry groups (entryBox.y - MARGIN)
            
            const minAllowedTurnY = effectiveSourceY + 20;
            let maxAllowedTurnY = targetY - 20; // Default: must be above target
            
            if (entryGroups.length > 0) {
                const firstEntryGroup = entryGroups[0];
                const entryBox = boxMap.get(firstEntryGroup);
                if (entryBox) {
                    // Must turn above the entry group
                    maxAllowedTurnY = Math.min(maxAllowedTurnY, entryBox.y - MARGIN);
                }
            }
            
            // Use divergence.y if it's within the valid range, otherwise clamp it
            if (divergence.y >= minAllowedTurnY && divergence.y <= maxAllowedTurnY) {
                // Divergence point is in valid range - use it
                turnY = divergence.y;
            } else if (divergence.y < minAllowedTurnY) {
                // Divergence point is too high (too close to source) - use minimum
                turnY = minAllowedTurnY;
            } else {
                // Divergence point is too low (would hit obstacles) - use maximum
                // This shouldn't normally happen since divergence.y = sourceY + MARGIN is small
                turnY = maxAllowedTurnY;
            }
        }

        // First, identify all boxes we need to avoid (not containing source or target)
        const boxesToAvoid = boxes.filter((box) => {
            // Check if source or target is inside this box (if so, don't avoid it)
            if (
                isInsideGroup(source, box.id) ||
                isInsideGroup(target, box.id)
            ) {
                return false;
            }
            // Check if source or target IS this group
            if (source === box.id || target === box.id) {
                return false;
            }
            return true;
        });

        // Check if a point is in a valid gap between groups (not inside any group's bounding box)
        function isInValidGap(x: number, relevantBoxes: GroupBox[]): boolean {
            for (const box of relevantBoxes) {
                // Point is inside the box (without margin - the actual box boundary)
                if (x > box.x && x < box.x + box.width) {
                    return false;
                }
            }
            return true;
        }

        // Check if we can draw a straight vertical line from source to target
        // This is possible if both sourceX and targetX are in valid gaps between sibling groups
        const canGoStraightVertical = (() => {
            if (Math.abs(sourceX - targetX) > 1) return false; // X positions must be almost the same
            
            // Find boxes that are in our Y range
            const boxesInYRange = boxesToAvoid.filter((box) => {
                const boxTop = box.y;
                const boxBottom = box.y + box.height;
                return boxBottom > sourceY && boxTop < targetY;
            });
            
            // Check if sourceX is in a valid gap (not inside any box)
            return isInValidGap(sourceX, boxesInYRange);
        })();

        // Check if a smoothstep path (down, across, down) intersects any boxes
        // Use effective source position (after exit port waypoints) for intersection checks
        function pathIntersectsBox(turnY: number, box: GroupBox): boolean {
            const boxLeft = box.x - MARGIN;
            const boxRight = box.x + box.width + MARGIN;
            const boxTop = box.y - MARGIN;
            const boxBottom = box.y + box.height + MARGIN;

            // Check vertical segment 1: effectiveSourceX, effectiveSourceY -> effectiveSourceX, turnY
            if (effectiveSourceX > boxLeft && effectiveSourceX < boxRight) {
                const segTop = Math.min(effectiveSourceY, turnY);
                const segBottom = Math.max(effectiveSourceY, turnY);
                if (segBottom > boxTop && segTop < boxBottom) return true;
            }

            // Check horizontal segment: effectiveSourceX, turnY -> targetX, turnY
            if (turnY > boxTop && turnY < boxBottom) {
                const segLeft = Math.min(effectiveSourceX, targetX);
                const segRight = Math.max(effectiveSourceX, targetX);
                if (segRight > boxLeft && segLeft < boxRight) return true;
            }

            // Check vertical segment 2: targetX, turnY -> targetX, targetY
            if (targetX > boxLeft && targetX < boxRight) {
                const segTop = Math.min(turnY, targetY);
                const segBottom = Math.max(turnY, targetY);
                if (segBottom > boxTop && segTop < boxBottom) return true;
            }

            return false;
        }

        // If we can go straight vertical, just do it (no avoidance needed)
        if (canGoStraightVertical) {
            waypoints.push({ x: sourceX, y: targetY });
            return buildPathFromWaypoints(waypoints);
        }

        // Find boxes that the simple path would intersect
        const intersectingBoxes = boxesToAvoid.filter((box) =>
            pathIntersectsBox(turnY, box),
        );

        if (intersectingBoxes.length > 0) {
            // Need to route around boxes
            // If we have exit waypoints, start avoidance from the last waypoint position
            return buildAvoidancePath(
                effectiveSourceX,
                effectiveSourceY,
                targetX,
                targetY,
                boxesToAvoid,
                waypoints,  // Pass existing waypoints including exit ports
            );
        }

        // Simple orthogonal path: down (from effective source), across, down
        // Only add down waypoint if we need to move vertically from effective source
        if (turnY !== effectiveSourceY) {
            waypoints.push({ x: effectiveSourceX, y: turnY });
        }
        // Move horizontally to target X if needed
        if (effectiveSourceX !== targetX) {
            waypoints.push({ x: targetX, y: turnY });
        }
        waypoints.push({ x: targetX, y: targetY });

        // Build SVG path
        return buildPathFromWaypoints(waypoints);
    }

    function buildPathFromWaypoints(
        waypoints: Array<{ x: number; y: number }>,
    ): string {
        if (waypoints.length === 0) return "";
        
        // Check if we need to add a confluence point for edge bundling
        // Confluence applies when there are multiple edges going to the same target
        const confluence = getConfluencePoint();
        if (confluence && waypoints.length >= 2) {
            // Get the last waypoint (which should be the target)
            const lastWp = waypoints[waypoints.length - 1];
            
            // Only apply confluence if the last waypoint is the target
            if (Math.abs(lastWp.x - targetX) < 1 && Math.abs(lastWp.y - targetY) < 1) {
                // Check if this is NOT a straight vertical line
                const hasHorizontalMove = waypoints.some((wp, i) => {
                    if (i === 0) return false;
                    return Math.abs(wp.x - waypoints[i-1].x) > 1;
                });
                
                if (hasHorizontalMove) {
                    // Find the LAST horizontal segment (the one that moves to targetX)
                    // We want to ensure this happens at confluence.y
                    
                    // Rebuild waypoints: everything before the horizontal-to-targetX, then confluence, then target
                    const newWaypoints: Array<{ x: number; y: number }> = [];
                    let lastXBeforeTarget: number | null = null;
                    
                    for (let i = 0; i < waypoints.length - 1; i++) {
                        const wp = waypoints[i];
                        const nextWp = waypoints[i + 1];
                        
                        // Check if this segment or the next one moves to targetX
                        if (Math.abs(nextWp.x - targetX) < 1 && Math.abs(wp.x - targetX) > 1) {
                            // This is the segment before we move to targetX
                            // Record the X position and stop
                            lastXBeforeTarget = wp.x;
                            newWaypoints.push(wp);
                            break;
                        }
                        newWaypoints.push(wp);
                    }
                    
                    if (lastXBeforeTarget !== null) {
                        // Now add the confluence routing
                        const lastWp = newWaypoints[newWaypoints.length - 1];
                        
                        // ALWAYS go to confluence.y first on current X (orthogonal move)
                        // This ensures we don't create diagonal lines
                        if (Math.abs(lastWp.y - confluence.y) > 1) {
                            newWaypoints.push({ x: lastWp.x, y: confluence.y });
                        }
                        // Then move horizontally to targetX at confluence.y
                        newWaypoints.push({ x: targetX, y: confluence.y });
                        // Go to target
                        newWaypoints.push({ x: targetX, y: targetY });
                        
                        // Use new waypoints
                        waypoints.length = 0;
                        waypoints.push(...newWaypoints);
                    }
                }
            }
        }
        
        // Remove duplicate consecutive waypoints
        const cleanedWaypoints: Array<{ x: number; y: number }> = [waypoints[0]];
        for (let i = 1; i < waypoints.length; i++) {
            const prev = cleanedWaypoints[cleanedWaypoints.length - 1];
            const curr = waypoints[i];
            if (Math.abs(prev.x - curr.x) > 0.5 || Math.abs(prev.y - curr.y) > 0.5) {
                cleanedWaypoints.push(curr);
            }
        }
        
        // Remove collinear points (points that lie on a straight line between their neighbors)
        const optimizedWaypoints: Array<{ x: number; y: number }> = [cleanedWaypoints[0]];
        for (let i = 1; i < cleanedWaypoints.length - 1; i++) {
            const prev = optimizedWaypoints[optimizedWaypoints.length - 1];
            const curr = cleanedWaypoints[i];
            const next = cleanedWaypoints[i + 1];
            
            // Check if prev, curr, next are collinear (all on same X or all on same Y)
            const sameX = Math.abs(prev.x - curr.x) < 0.5 && Math.abs(curr.x - next.x) < 0.5;
            const sameY = Math.abs(prev.y - curr.y) < 0.5 && Math.abs(curr.y - next.y) < 0.5;
            
            // Skip curr if it's collinear with prev and next
            if (!sameX && !sameY) {
                optimizedWaypoints.push(curr);
            }
        }
        // Always add the last point
        if (cleanedWaypoints.length > 1) {
            optimizedWaypoints.push(cleanedWaypoints[cleanedWaypoints.length - 1]);
        }
        
        let path = `M ${optimizedWaypoints[0].x} ${optimizedWaypoints[0].y}`;
        for (let i = 1; i < optimizedWaypoints.length; i++) {
            path += ` L ${optimizedWaypoints[i].x} ${optimizedWaypoints[i].y}`;
        }
        return path;
    }

    function buildAvoidancePath(
        srcX: number,
        srcY: number,
        tgtX: number,
        tgtY: number,
        allObstacles: GroupBox[],
        existingWaypoints: Array<{ x: number; y: number }> = [],
    ): string {
        const boxes = get(groupBoxesStore);
        const waypoints: Array<{ x: number; y: number }> = [...existingWaypoints];
        
        // If no existing waypoints, start with source position
        if (waypoints.length === 0) {
            waypoints.push({ x: srcX, y: srcY });
        }

        let currentX = srcX;
        let currentY = srcY;

        // Check for sibling edges to determine divergence point
        // SIMPLIFIED: Always use divergence point for consistency
        // Since we can't reliably detect siblings (store may not be fully populated),
        // we just always use sourceY + MARGIN as the divergence point
        const divergence = getDivergencePoint();
        // Use divergence Y as the split point (always, for consistency)
        const divergenceY = divergence ? divergence.y : null;

        // Find parent groups that contain both source and target
        // These define the boundaries we must stay within
        const sourceHierarchy = getGroupHierarchy(source);
        const targetHierarchy = getGroupHierarchy(target);
        const containingGroups = sourceHierarchy.filter((g) =>
            targetHierarchy.includes(g),
        );

        // Get the innermost containing group's boundaries (with clearance)
        // Note: Groups should have enough right padding reserved for avoidance paths
        // since avoidance paths always go right
        let minAllowedX = -Infinity;
        let maxAllowedX = Infinity;

        if (containingGroups.length > 0) {
            // The first one is the innermost common ancestor
            const innermostContainer = containingGroups[0];
            const containerBox = boxes.find((b) => b.id === innermostContainer);
            if (containerBox) {
                // Must stay MARGIN inside the container boundaries
                minAllowedX = containerBox.x + MARGIN;
                maxAllowedX =
                    containerBox.x + containerBox.width - MARGIN;
            }
        }

        // Filter to only obstacles that are between source and target vertically
        // and could potentially block our path
        const relevantObstacles = allObstacles.filter((box) => {
            const boxTop = box.y - MARGIN;
            const boxBottom = box.y + box.height + MARGIN;

            // Box must be in the Y range we're traversing
            if (boxBottom < srcY || boxTop > tgtY) return false;

            // Box must overlap with either srcX or tgtX column, or be between them
            const boxLeft = box.x - MARGIN;
            const boxRight = box.x + box.width + MARGIN;
            const minX = Math.min(srcX, tgtX);
            const maxX = Math.max(srcX, tgtX);

            // If box is completely to the left or right of our X range, skip it
            if (boxRight < minX || boxLeft > maxX) {
                // Unless our vertical segment passes through it
                if (srcX > boxLeft && srcX < boxRight) return true;
                if (tgtX > boxLeft && tgtX < boxRight) return true;
                return false;
            }

            return true;
        });

        // Sort obstacles by Y position
        relevantObstacles.sort((a, b) => a.y - b.y);

        for (const box of relevantObstacles) {
            const boxLeft = box.x - MARGIN;
            const boxRight = box.x + box.width + MARGIN;
            const boxTop = box.y - MARGIN;
            const boxBottom = box.y + box.height + MARGIN;

            // Check if we actually need to go around this box
            // (our current X position would pass through it)
            const wouldPassThrough =
                currentX > boxLeft &&
                currentX < boxRight &&
                currentY < boxBottom &&
                tgtY > boxTop;

            if (!wouldPassThrough) continue;

            // ALWAYS go RIGHT for avoidance paths - this ensures consistent behavior
            // and guarantees the layout has reserved enough space on the right side
            let finalX = boxRight;

            // Clamp finalX to stay within the containing group's boundaries
            finalX = Math.max(finalX, minAllowedX);
            finalX = Math.min(finalX, maxAllowedX);

            // Calculate "smart" split point - align with where sibling edges going INTO this group would turn
            // For edges entering a group, the turn point is: entryBox.y - MARGIN
            // This is the same calculation used in getPath() for entryGroups
            const siblingTurnY = box.y - MARGIN;

            // Use the sibling turn point if it's above the source with enough space
            // Otherwise fall back to MARGIN above the box
            let splitY: number;
            
            // DIVERGENCE OVERRIDE: If we have siblings from same source, use the divergence point
            // This ensures all edges from the same source split at the same Y level
            if (divergenceY !== null && divergenceY > srcY + 20 && divergenceY < siblingTurnY) {
                // Divergence point is valid and above the natural split - use it
                splitY = divergenceY;
            } else if (siblingTurnY > srcY + 20) {
                // Sibling turn point is safely below the source - use it
                splitY = siblingTurnY;
            } else {
                // Sibling turn would be too close to source - use clearance
                splitY = boxTop - MARGIN;
            }

            // Make sure splitY is below current position
            splitY = Math.max(splitY, currentY + 20);
            if (splitY > currentY) {
                waypoints.push({ x: currentX, y: splitY });
                currentY = splitY;
            }

            // Go around the box using the calculated side
            waypoints.push({ x: finalX, y: currentY });
            
            // KEY FIX: Don't go all the way to boxBottom if target is above boxBottom
            // This prevents the edge from going below the target and then back up
            // Check if the target X is now reachable without going through any more obstacles
            
            if (tgtY < boxBottom && tgtX >= finalX - MARGIN) {
                // Target is above boxBottom and to the right of our current position
                // We can go directly to target Y level without going to boxBottom
                currentX = finalX;
                // Don't update currentY to boxBottom - keep it at splitY
            } else {
                // Need to go all the way around
                waypoints.push({ x: finalX, y: boxBottom });
                currentX = finalX;
                currentY = boxBottom;
            }
        }

        // Connect to target with orthogonal segments
        if (currentX !== tgtX) {
            waypoints.push({ x: tgtX, y: currentY });
        }
        waypoints.push({ x: tgtX, y: tgtY });

        return buildPathFromWaypoints(waypoints);
    }

    // Track path computation - only recompute when store changes
    let path = '';
    let lastStoreLength = 0;
    
    // Initial path computation
    $: {
        const edges = $allEdgesStore;
        // Only recompute if store length changed (new edges registered)
        // This prevents infinite loops while still allowing path updates when siblings appear
        if (edges.length !== lastStoreLength) {
            lastStoreLength = edges.length;
            path = getPath();
        }
    }
    
    // Also recompute when position changes
    $: if (sourceX || sourceY || targetX || targetY) {
        path = getPath();
    }
</script>

<BaseEdge {id} {path} {style} {markerEnd} />
